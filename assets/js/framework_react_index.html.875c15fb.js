"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([[565],{5525:(n,a,s)=>{s.r(a),s.d(a,{comp:()=>p,data:()=>c});var e=s(6254);const t={},p=(0,s(6995).A)(t,[["render",function(n,a){return(0,e.uX)(),(0,e.CE)("div",null,a[0]||(a[0]=[(0,e.Fv)('<h1 id="基础" tabindex="-1"><a class="header-anchor" href="#基础"><span>基础</span></a></h1><h2 id="_1-react-组件之间的通信方式" tabindex="-1"><a class="header-anchor" href="#_1-react-组件之间的通信方式"><span>1.React 组件之间的通信方式</span></a></h2><h2 id="_2-组件的生命周期" tabindex="-1"><a class="header-anchor" href="#_2-组件的生命周期"><span>2.组件的生命周期</span></a></h2><h2 id="_3-react-context" tabindex="-1"><a class="header-anchor" href="#_3-react-context"><span>3.React Context</span></a></h2><h2 id="_4-高阶组件-hoc" tabindex="-1"><a class="header-anchor" href="#_4-高阶组件-hoc"><span>4.高阶组件（HOC）</span></a></h2><h2 id="_5-react-如何避免不必要的渲染" tabindex="-1"><a class="header-anchor" href="#_5-react-如何避免不必要的渲染"><span>5.React 如何避免不必要的渲染</span></a></h2><h3 id="react-渲染控制的方式" tabindex="-1"><a class="header-anchor" href="#react-渲染控制的方式"><span>React 渲染控制的方式</span></a></h3><p>React 渲染控制的方式可以分为以下几类：</p><ul><li>从父组件直接隔断子组件的渲染，如缓存 React.element 对象、React.useMemo。</li><li>组件内部控制是否渲染，如 PureComponent、shouldComponentUpdate、React.memo。</li><li>打破渲染限制，如 forceUpdate、context 穿透。</li></ul><p>（1）从父组件直接隔断子组件的渲染</p><p>1）缓存 React.element 对象</p><p>该方法适用于类组件。当父组件需要重新渲染，而子组件没有必要跟着一起渲染时，可以使用 React.cloneElement 缓存子组件。如果子组件的 props 变化，则返回新的 element 对象，否则返回缓存的 element 对象。</p><p>2）React.useMemo</p><p>该方法适用于函数组件。</p><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx"><pre><code><span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> useMemo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span><span class="token punctuation">;</span></span>\n<span class="line"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>\n<span class="line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>numberA<span class="token punctuation">,</span> setNumberA<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line">  <span class="token keyword">return</span> <span class="token punctuation">(</span></span>\n<span class="line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text"></span>\n<span class="line">      </span><span class="token punctuation">{</span><span class="token function">useMemo</span><span class="token punctuation">(</span></span>\n<span class="line">        <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span></span>\n<span class="line">          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Child</span></span> <span class="token attr-name">numberA</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>numberA<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span></span>\n<span class="line">        <span class="token punctuation">)</span><span class="token punctuation">,</span></span>\n<span class="line">        <span class="token punctuation">[</span>numberA<span class="token punctuation">]</span></span>\n<span class="line">      <span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token plain-text"></span>\n<span class="line">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setNumberA</span><span class="token punctuation">(</span>numberA <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">+</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text"></span>\n<span class="line">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></span>\n<span class="line">  <span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line"><span class="token punctuation">}</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）组件内部控制是否渲染</p><p>1）PureComponent</p><p>PureComponent 是一种组件本身的渲染优化策略，当类组件选择继承 PureComponent 就意味着要遵循其渲染规则：浅比较 state 和 props 是否相等。</p><p>PureComponent 的浅比较规则只会比较基础数据类型，</p><p>（3）打破渲染限制</p><h3 id="对渲染控制的思考" tabindex="-1"><a class="header-anchor" href="#对渲染控制的思考"><span>对渲染控制的思考</span></a></h3><p>（1）有没有必要在乎组件不必要的渲染 在正常情况下，无须过分在乎 React 没有必要的渲染，要理解执行 render 不等于真正的浏览器渲染视图，render 阶段执行是在 js 当中，js 中运行代码远快于浏览器的 Rendering 和 Painting 的，更何况 React 还提供了 diff 算法等手段去复用真实的 DOM。</p><p>（2）什么时候需要注意渲染节流</p><h2 id="_6-react-的-diff-算法" tabindex="-1"><a class="header-anchor" href="#_6-react-的-diff-算法"><span>6.React 的 diff 算法</span></a></h2>',24)]))}]]),c=JSON.parse('{"path":"/framework/react/","title":"基础","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"1.React 组件之间的通信方式","slug":"_1-react-组件之间的通信方式","link":"#_1-react-组件之间的通信方式","children":[]},{"level":2,"title":"2.组件的生命周期","slug":"_2-组件的生命周期","link":"#_2-组件的生命周期","children":[]},{"level":2,"title":"3.React Context","slug":"_3-react-context","link":"#_3-react-context","children":[]},{"level":2,"title":"4.高阶组件（HOC）","slug":"_4-高阶组件-hoc","link":"#_4-高阶组件-hoc","children":[]},{"level":2,"title":"5.React 如何避免不必要的渲染","slug":"_5-react-如何避免不必要的渲染","link":"#_5-react-如何避免不必要的渲染","children":[{"level":3,"title":"React 渲染控制的方式","slug":"react-渲染控制的方式","link":"#react-渲染控制的方式","children":[]},{"level":3,"title":"对渲染控制的思考","slug":"对渲染控制的思考","link":"#对渲染控制的思考","children":[]}]},{"level":2,"title":"6.React 的 diff 算法","slug":"_6-react-的-diff-算法","link":"#_6-react-的-diff-算法","children":[]}],"git":{"updatedTime":1744715059000,"contributors":[{"name":"caiyihong","username":"caiyihong","email":"caiyihong@baidu.com","commits":1,"url":"https://github.com/caiyihong"}],"changelog":[{"hash":"7c3de3ecf5f8b832b82199e945a4f458622ef747","time":1744715059000,"email":"caiyihong@baidu.com","author":"caiyihong","message":"update"}]},"filePathRelative":"framework/react/index.md","excerpt":"\\n<h2>1.React 组件之间的通信方式</h2>\\n<h2>2.组件的生命周期</h2>\\n<h2>3.React Context</h2>\\n<h2>4.高阶组件（HOC）</h2>\\n<h2>5.React 如何避免不必要的渲染</h2>\\n<h3>React 渲染控制的方式</h3>\\n<p>React 渲染控制的方式可以分为以下几类：</p>\\n<ul>\\n<li>从父组件直接隔断子组件的渲染，如缓存 React.element 对象、React.useMemo。</li>\\n<li>组件内部控制是否渲染，如 PureComponent、shouldComponentUpdate、React.memo。</li>\\n<li>打破渲染限制，如 forceUpdate、context 穿透。</li>\\n</ul>"}')}}]);