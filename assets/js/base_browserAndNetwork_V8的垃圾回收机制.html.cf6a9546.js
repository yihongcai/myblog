"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([[431],{2013:(a,e,i)=>{i.r(e),i.d(e,{comp:()=>n,data:()=>c});var l=i(6254);const t={},n=(0,i(6995).A)(t,[["render",function(a,e){return(0,l.uX)(),(0,l.CE)("div",null,e[0]||(e[0]=[(0,l.Fv)('<h1 id="v8-的垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#v8-的垃圾回收机制"><span>V8 的垃圾回收机制</span></a></h1><p>JavaScript 中的数据存储分为堆存储和栈存储。堆存储用于存储对象，栈存储用于存储基本类型的数据。</p><p>V8 引擎的垃圾回收机制主要针对堆存储进行管理。</p><h2 id="栈的垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#栈的垃圾回收机制"><span>栈的垃圾回收机制</span></a></h2><p>栈通过移动 ESP 指针（记录当前执行位置的指针）实现内存管理。</p><p>在执行栈中，当函数执行结束后，JS 引擎通过向下移动 ESP 指针来销毁函数保存在栈中的执行上下文。</p><h2 id="堆的垃圾回收机制-garbage-collection-gc" tabindex="-1"><a class="header-anchor" href="#堆的垃圾回收机制-garbage-collection-gc"><span>堆的垃圾回收机制（Garbage Collection， GC）</span></a></h2><p>V8 引擎将对象存储在堆（Heap）中，并将堆划分为新生代和老生代，分别使用不同的 GC 策略。</p><table><thead><tr><th>内存区域</th><th>特点</th><th>回收策略</th></tr></thead><tbody><tr><td>新生代（Young Generation）</td><td>存放存活时间短的小对象（如局部变量、临时对象）</td><td>Scavenge 算法</td></tr><tr><td>老生代（Old Generation）</td><td>存放存活时间长或较大的对象（如全局变量、闭包）</td><td>Mark-Sweep 和 Mark-Compact 算法</td></tr></tbody></table><div class="hint-container tip"><p class="hint-container-title">对象的生命周期</p><ol><li>新创建的对象优先存入新生代（小对象）。</li><li>对象在新生代存活一定时间后，会被移动到老生代。（晋升）</li><li>老生代的对象会被增量标记-清除（Mark-Sweep &amp; Mark-Compact）。</li></ol></div><h3 id="新生代垃圾回收-scavenge-算法" tabindex="-1"><a class="header-anchor" href="#新生代垃圾回收-scavenge-算法"><span>新生代垃圾回收（Scavenge 算法）</span></a></h3><p>Scavenge 算法将堆内存分为两个大小相等的区域：对象区域和空闲区域。</p><p>具体垃圾回收过程如下：</p><ul><li>遍历对象区域，标记存活的对象。</li><li>将存活的对象复制到空闲区域，并有序排列（避免碎片化）。</li><li>将对象区域和空闲区域进行角色翻转。</li></ul><div class="hint-container tip"><p class="hint-container-title">对象从新生代晋升到老生代条件</p><ol><li>在新生代存活超过两次 GC。</li><li>空闲区域空间使用率超过 25%时，部分对象会提前晋升。</li></ol></div><h3 id="老生代垃圾回收-mark-sweep-mark-compact-算法" tabindex="-1"><a class="header-anchor" href="#老生代垃圾回收-mark-sweep-mark-compact-算法"><span>老生代垃圾回收（Mark-Sweep &amp; Mark-Compact 算法）</span></a></h3><p>老生代存放生命周期较长的大对象，V8 使用 Maek-Sweep 和 Mark-Compact 算法进行垃圾回收。具体过程如下：</p><h4 id="mark-sweep-算法-标记-清除" tabindex="-1"><a class="header-anchor" href="#mark-sweep-算法-标记-清除"><span>Mark-Sweep 算法（标记-清除）</span></a></h4><ul><li>标记：从根对象出发，递归遍历所有可到达的对象，并标记为存活；未被标记的对象即为不可到达的对象（垃圾）。</li><li>清除：清除未被标记的对象，释放内存。</li></ul><p>缺点：会产生内存碎片，影响后续内存分配。</p><h4 id="mark-compact-算法-标记-整理" tabindex="-1"><a class="header-anchor" href="#mark-compact-算法-标记-整理"><span>Mark-Compact 算法（标记-整理）</span></a></h4><ul><li>标记：标记存活对象。</li><li>整理：将存活对象移动到连续的内存区域。</li><li>清除：释放无用对象。</li></ul><h2 id="触发垃圾回收的场景" tabindex="-1"><a class="header-anchor" href="#触发垃圾回收的场景"><span>触发垃圾回收的场景</span></a></h2><p>V8 何时触发垃圾回收？</p><ol><li>新生代堆满（超过 64MB ～ 128MB）。</li><li>老生代堆满（超过 700MB ～ 1.4GB）。</li><li>主动调用<code>global.gc()</code>（Node.js 需要<code>--expose-gc</code>参数）。</li></ol>',25)]))}]]),c=JSON.parse('{"path":"/base/browserAndNetwork/V8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html","title":"V8 的垃圾回收机制","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"栈的垃圾回收机制","slug":"栈的垃圾回收机制","link":"#栈的垃圾回收机制","children":[]},{"level":2,"title":"堆的垃圾回收机制（Garbage Collection， GC）","slug":"堆的垃圾回收机制-garbage-collection-gc","link":"#堆的垃圾回收机制-garbage-collection-gc","children":[{"level":3,"title":"新生代垃圾回收（Scavenge 算法）","slug":"新生代垃圾回收-scavenge-算法","link":"#新生代垃圾回收-scavenge-算法","children":[]},{"level":3,"title":"老生代垃圾回收（Mark-Sweep & Mark-Compact 算法）","slug":"老生代垃圾回收-mark-sweep-mark-compact-算法","link":"#老生代垃圾回收-mark-sweep-mark-compact-算法","children":[]}]},{"level":2,"title":"触发垃圾回收的场景","slug":"触发垃圾回收的场景","link":"#触发垃圾回收的场景","children":[]}],"git":{"updatedTime":1743355869000,"contributors":[{"name":"caiyihong","username":"caiyihong","email":"caiyihong@baidu.com","commits":2,"url":"https://github.com/caiyihong"}],"changelog":[{"hash":"610772de9b3e76a50a4f4866530f9605a3193f0c","time":1743355869000,"email":"caiyihong@baidu.com","author":"caiyihong","message":"update"},{"hash":"f6cf4bab0a3096d941cba6dca497f44990019ea7","time":1743351643000,"email":"caiyihong@baidu.com","author":"caiyihong","message":"新增函数this指向、跨标签页通信、垃圾回收机制"}]},"filePathRelative":"base/browserAndNetwork/V8的垃圾回收机制.md","excerpt":"\\n<p>JavaScript 中的数据存储分为堆存储和栈存储。堆存储用于存储对象，栈存储用于存储基本类型的数据。</p>\\n<p>V8 引擎的垃圾回收机制主要针对堆存储进行管理。</p>\\n<h2>栈的垃圾回收机制</h2>\\n<p>栈通过移动 ESP 指针（记录当前执行位置的指针）实现内存管理。</p>\\n<p>在执行栈中，当函数执行结束后，JS 引擎通过向下移动 ESP 指针来销毁函数保存在栈中的执行上下文。</p>\\n<h2>堆的垃圾回收机制（Garbage Collection， GC）</h2>\\n<p>V8 引擎将对象存储在堆（Heap）中，并将堆划分为新生代和老生代，分别使用不同的 GC 策略。</p>"}')}}]);