"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([[110],{9829:(i,a,h)=>{h.r(a),h.d(a,{comp:()=>n,data:()=>l});var t=h(6254);const s={},n=(0,h(6995).A)(s,[["render",function(i,a){return(0,t.uX)(),(0,t.CE)("div",null,a[0]||(a[0]=[(0,t.Fv)('<h1 id="this-指向" tabindex="-1"><a class="header-anchor" href="#this-指向"><span>this 指向</span></a></h1><p>由于 this 是和执行上下文绑定的，所以 this 也分为全局执行上下文中的 this 和函数执行上下文中的 this。</p><h2 id="全局执行上下文中的-this" tabindex="-1"><a class="header-anchor" href="#全局执行上下文中的-this"><span>全局执行上下文中的 this</span></a></h2><p>全局执行上下文中的 this 一般指向 window，严格模式下指向 undefined。</p><h2 id="函数执行上下文中的-this" tabindex="-1"><a class="header-anchor" href="#函数执行上下文中的-this"><span>函数执行上下文中的 this</span></a></h2><p>函数执行上下文中的 this 根据函数调用方式的不同而不同。具体分为以下几种情况：</p><p>1.作为函数被调用，this 指向全局 window。</p><p>2.作为对象属性被调用，this 执行该对象。</p><p>3.作为构造函数被调用，this 指向当前实例对象。</p><p>4.使用 call、apply 和 bind 改变 this 指向。</p><div class="hint-container tip"><p class="hint-container-title">简单粗暴的判断方法</p><p>看执行函数时函数前面有没有点。如果有点，this 指向点前面的对象；如果没有，this 指向全局 window。</p></div><h3 id="call、apply-和-bind" tabindex="-1"><a class="header-anchor" href="#call、apply-和-bind"><span>call、apply 和 bind</span></a></h3><p>call、apply 和 bind 方法都是用于修改函数的 this 指向。</p><p>（1）call、apply 和 bind 的区别</p><p>call 和 apply 方法都是立即执行，只是参数上有所区别。</p><ul><li>call 方法接收一个参数列表，<code>fn.call(this, arg1, arg2,..., argn)</code></li><li>apply 方法接收一个参数数组，<code>fn.apply(this, [arg1, arg2,..., argn])</code></li></ul><p>bind 方法不会立即执行，而是返回一个闭包函数。</p><ul><li>bind 方法接收一个参数列表，<code>fn.bind(this, arg1, arg2,..., argn)</code></li></ul><p>（2）多次使用 bind 绑定 this，函数最后绑定的是哪个 this 呢？</p><p>由于 bind 的原理是返回一个闭包函数，所以多次使用 bind 绑定 this，函数最后绑定的是最后一次的 this。</p>',20)]))}]]),l=JSON.parse('{"path":"/base/javascript/this%E6%8C%87%E5%90%91.html","title":"this 指向","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"全局执行上下文中的 this","slug":"全局执行上下文中的-this","link":"#全局执行上下文中的-this","children":[]},{"level":2,"title":"函数执行上下文中的 this","slug":"函数执行上下文中的-this","link":"#函数执行上下文中的-this","children":[{"level":3,"title":"call、apply 和 bind","slug":"call、apply-和-bind","link":"#call、apply-和-bind","children":[]}]}],"git":{"updatedTime":1743351643000,"contributors":[{"name":"caiyihong","username":"caiyihong","email":"caiyihong@baidu.com","commits":2,"url":"https://github.com/caiyihong"}],"changelog":[{"hash":"f6cf4bab0a3096d941cba6dca497f44990019ea7","time":1743351643000,"email":"caiyihong@baidu.com","author":"caiyihong","message":"新增函数this指向、跨标签页通信、垃圾回收机制"},{"hash":"01230644abb783e79e8bff855325dd6d2228a9fc","time":1743254131000,"email":"caiyihong@baidu.com","author":"caiyihong","message":"update"}]},"filePathRelative":"base/javascript/this指向.md","excerpt":"\\n<p>由于 this 是和执行上下文绑定的，所以 this 也分为全局执行上下文中的 this 和函数执行上下文中的 this。</p>\\n<h2>全局执行上下文中的 this</h2>\\n<p>全局执行上下文中的 this 一般指向 window，严格模式下指向 undefined。</p>\\n<h2>函数执行上下文中的 this</h2>\\n<p>函数执行上下文中的 this 根据函数调用方式的不同而不同。具体分为以下几种情况：</p>\\n<p>1.作为函数被调用，this 指向全局 window。</p>\\n<p>2.作为对象属性被调用，this 执行该对象。</p>\\n<p>3.作为构造函数被调用，this 指向当前实例对象。</p>"}')}}]);