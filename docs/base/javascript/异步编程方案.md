# 异步编程方案

在 JavaScript 中，异步编程是核心特征之一，主要用于处理 I/O 操作、网络请求、定时器等任务。常见的 JS 异步方案有以下几种：

## 回调函数（Callback）

## Promise

（1）具体实现（PromiseA+ 规范）

::: details Promise 具体实现

```js
/**
 * PromiseA+ 规范
 * 1. Promise状态必须是以下三种状态之一：等待中（pending）、已完成（fulfilled）、已拒绝（rejected）
 * 2. 一个Promise对象必须提供一个then方法去访问当前
 */
const Status = {
  PENDING: 'pending',
  FULFILLED: 'fulfilled',
  REJECTED: 'rejected',
};
class MyPromise {
  constructor(executor) {
    this.status = Status.PENDING;
    this.value = undefined;
    this.reason = undefined;
    this.executor(executor);
  }

  executor(executor) {
    const resolve = (value) => {
      this.status = Status.FULFILLED;
      this.value = value;
    };
    const reject = (reason) => {
      this.status = Status.REJECTED;
      this.reason = reason;
    };
    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }

  then(onfulfilled, onrejected) {
    let timer = null;
    let ref = null;
    let res = new MyPromise(() => {});
    timer = setInterval(() => {
      if (this.status === Status.FULFILLED || this.status === Status.REJECTED) {
        clearInterval(timer);
        try {
          if (this.status === Status.FULFILLED) {
            ref = onfulfilled(this.value);
          } else {
            ref = onrejected(this.reason);
          }
          if (ref instanceof MyPromise) {
            timer = setInterval(() => {
              if (
                ref.status === Status.FULFILLED ||
                ref.status === Status.REJECTED
              ) {
                clearInterval(timer);
                res.status = ref.status;
                res.value = ref.value;
                res.reason = ref.reason;
              }
            }, 0);
          } else {
            // onfulfilled或onrejected没有返回值 或 返回值不是promise
            res.status = Status.REJECTED;
            res.reason = ref;
          }
        } catch (error) {
          res.status = Status.REJECTED;
          res.reason = error;
        }
      }
    }, 0);
    return res;
  }
}
```

:::

::: details Promise.all 和 Promise.allSettled 具体实现
:::

（2）Promise 怎么取消

（3）Promise 错误捕获

（4）代码实现
::: details 使用 Promise 实现带并发限制的异步任务调度器
:::

::: details 使用 Promise 实现红绿灯（红灯 3 秒，绿灯 1 秒，黄灯 2 秒）
:::

::: details Promise 代码执行顺序
:::

## Async / Await

## Web Workers（多线程）

Web Worker 允许 JavaScript 运行在后台线程中，避免阻塞主线程，适用于 CPU 密集型任务（如大数据计算、图片处理等）。

（1）具体实现

1）主线程（main.js）

```js
const worker = new Worker('worker.js');
worker.postMessage(10); // 发送数据到worker线程
worker.onmessage = (event) => {
  console.log('Worker 计算结果：', event.data);
};
worker.onerror = (error) => {
  console.error('Worker 报错：', error);
};
```

2）Worker 线程（worker.js）

```js
self.onmessage = function (event) {
  let result = event.data * 2;
  self.postMessage(result);
};
```

（2）使用场景

- 大量计算（如 Fibonacci、排序）
- 图像/视频处理（如滤镜、压缩）
- 文件解析（如 CSV、JSON 大文件解析）
- 后台数据同步（如 WebSocket 监听）
